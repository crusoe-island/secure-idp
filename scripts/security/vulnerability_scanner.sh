#!/bin/bash
################################################################################

# Vulnerability Scanner for Crusoe IDP

################################################################################

# 

# This script performs comprehensive vulnerability scanning across the platform:

# - Container image scanning (Trivy, Grype)

# - Dependency vulnerability scanning (Snyk, npm audit, pip-audit)

# - Infrastructure as Code scanning (tfsec, checkov)

# - Kubernetes cluster scanning

# - Secret detection (detect-secrets, gitleaks)

# - SBOM generation

# - CVE database updates

# - Report aggregation and notifications

# 

# Usage:

# ./vulnerability_scanner.sh ‚Äìall

# ./vulnerability_scanner.sh ‚Äìimages ‚Äìdependencies

# ./vulnerability_scanner.sh ‚Äìseverity HIGH ‚Äìformat json

# ./vulnerability_scanner.sh ‚Äìimage myapp:v1.0.0 ‚Äìregistry acridpdev.azurecr.io

# 

# Author: Platform Security Team

# Version: 1.0

# Last Updated: 2024-12-21

# 

################################################################################

set -euo pipefail

# Script directory

SCRIPT_DIR=‚Äù$(cd ‚Äú$(dirname ‚Äú${BASH_SOURCE[0]}‚Äù)‚Äù && pwd)‚Äù
PROJECT_ROOT=‚Äù$(cd ‚Äú$SCRIPT_DIR/../..‚Äù && pwd)‚Äù

# Configuration

CONFIG_FILE=‚Äù${CONFIG_FILE:-$SCRIPT_DIR/scanner-config.yaml}‚Äù
RESULTS_DIR=‚Äù${RESULTS_DIR:-$PROJECT_ROOT/security-reports}‚Äù
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
REPORT_FILE=‚Äù$RESULTS_DIR/vulnerability-scan-$TIMESTAMP‚Äù

# Tool versions

TRIVY_VERSION=‚Äù${TRIVY_VERSION:-0.48.0}‚Äù
GRYPE_VERSION=‚Äù${GRYPE_VERSION:-0.73.0}‚Äù
SNYK_VERSION=‚Äù${SNYK_VERSION:-latest}‚Äù

# Colors for output

RED=‚Äô\033[0;31m‚Äô
YELLOW=‚Äô\033[1;33m‚Äô
GREEN=‚Äô\033[0;32m‚Äô
BLUE=‚Äô\033[0;34m‚Äô
NC=‚Äô\033[0m‚Äô # No Color

# Counters

TOTAL_CHECKS=0
CRITICAL_FINDINGS=0
HIGH_FINDINGS=0
MEDIUM_FINDINGS=0
LOW_FINDINGS=0
TOTAL_FINDINGS=0

# Default options

SCAN_IMAGES=false
SCAN_DEPENDENCIES=false
SCAN_IAC=false
SCAN_CLUSTER=false
SCAN_SECRETS=false
SCAN_SBOM=false
SCAN_ALL=false
SEVERITY_THRESHOLD=‚ÄúLOW‚Äù
OUTPUT_FORMAT=‚Äútext‚Äù
REGISTRY=‚Äù‚Äù
IMAGE_NAME=‚Äù‚Äù
FAIL_ON_CRITICAL=true
FAIL_ON_HIGH=false
SEND_NOTIFICATIONS=false
UPDATE_DB=true

################################################################################

# Utility Functions

################################################################################

log_info() {
echo -e ‚Äú${BLUE}[INFO]${NC} $1‚Äù
}

log_success() {
echo -e ‚Äú${GREEN}[SUCCESS]${NC} $1‚Äù
}

log_warning() {
echo -e ‚Äú${YELLOW}[WARNING]${NC} $1‚Äù
}

log_error() {
echo -e ‚Äú${RED}[ERROR]${NC} $1‚Äù
}

log_section() {
echo ‚Äú‚Äù
echo ‚Äú================================================================================‚Äù
echo ‚Äú$1‚Äù
echo ‚Äú================================================================================‚Äù
echo ‚Äú‚Äù
}

check_command() {
if ! command -v ‚Äú$1‚Äù &> /dev/null; then
return 1
fi
return 0
}

install_tool() {
local tool=$1
log_info ‚ÄúInstalling $tool‚Ä¶‚Äù

```
case $tool in
    trivy)
        if [[ "$OSTYPE" == "linux-gnu"* ]]; then
            wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
            echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
            sudo apt-get update && sudo apt-get install -y trivy
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            brew install aquasecurity/trivy/trivy
        fi
        ;;
    grype)
        curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
        ;;
    snyk)
        npm install -g snyk@$SNYK_VERSION
        ;;
    detect-secrets)
        pip install --break-system-packages detect-secrets
        ;;
    gitleaks)
        if [[ "$OSTYPE" == "linux-gnu"* ]]; then
            wget https://github.com/gitleaks/gitleaks/releases/download/v8.18.1/gitleaks_8.18.1_linux_x64.tar.gz
            tar -xzf gitleaks_8.18.1_linux_x64.tar.gz
            sudo mv gitleaks /usr/local/bin/
            rm gitleaks_8.18.1_linux_x64.tar.gz
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            brew install gitleaks
        fi
        ;;
    tfsec)
        if [[ "$OSTYPE" == "linux-gnu"* ]]; then
            curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            brew install tfsec
        fi
        ;;
    checkov)
        pip install --break-system-packages checkov
        ;;
    syft)
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
        ;;
    *)
        log_error "Unknown tool: $tool"
        return 1
        ;;
esac

log_success "$tool installed successfully"
```

}

check_and_install_tools() {
log_section ‚ÄúChecking Required Tools‚Äù

```
local tools=()

if [[ "$SCAN_IMAGES" == "true" ]] || [[ "$SCAN_ALL" == "true" ]]; then
    tools+=("trivy" "grype")
fi

if [[ "$SCAN_DEPENDENCIES" == "true" ]] || [[ "$SCAN_ALL" == "true" ]]; then
    tools+=("snyk")
fi

if [[ "$SCAN_IAC" == "true" ]] || [[ "$SCAN_ALL" == "true" ]]; then
    tools+=("tfsec" "checkov")
fi

if [[ "$SCAN_SECRETS" == "true" ]] || [[ "$SCAN_ALL" == "true" ]]; then
    tools+=("detect-secrets" "gitleaks")
fi

if [[ "$SCAN_SBOM" == "true" ]] || [[ "$SCAN_ALL" == "true" ]]; then
    tools+=("syft")
fi

for tool in "${tools[@]}"; do
    if ! check_command "$tool"; then
        log_warning "$tool not found"
        read -p "Install $tool? (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            install_tool "$tool"
        else
            log_error "$tool is required but not installed. Exiting."
            exit 1
        fi
    else
        log_success "$tool is installed"
    fi
done
```

}

update_vulnerability_databases() {
if [[ ‚Äú$UPDATE_DB‚Äù != ‚Äútrue‚Äù ]]; then
return
fi

```
log_section "Updating Vulnerability Databases"

# Update Trivy DB
if check_command trivy; then
    log_info "Updating Trivy database..."
    trivy image --download-db-only 2>&1 | grep -v "Downloading" || true
    log_success "Trivy database updated"
fi

# Update Grype DB
if check_command grype; then
    log_info "Updating Grype database..."
    grype db update 2>&1 | grep -v "Downloading" || true
    log_success "Grype database updated"
fi

# Snyk updates automatically
if check_command snyk; then
    log_info "Syncing Snyk database..."
    snyk auth "${SNYK_TOKEN:-}" &> /dev/null || log_warning "Snyk not authenticated"
fi
```

}

################################################################################

# Container Image Scanning

################################################################################

scan_image_trivy() {
local image=$1
local output_file=$2

```
log_info "Scanning $image with Trivy..."
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

# Scan with Trivy
local trivy_output
trivy_output=$(mktemp)

trivy image \
    --severity "$SEVERITY_THRESHOLD,HIGH,CRITICAL" \
    --format json \
    --output "$trivy_output" \
    "$image" 2>&1 || true

# Parse results
if [[ -f "$trivy_output" ]]; then
    local critical=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' "$trivy_output" 2>/dev/null || echo "0")
    local high=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' "$trivy_output" 2>/dev/null || echo "0")
    local medium=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "MEDIUM")] | length' "$trivy_output" 2>/dev/null || echo "0")
    local low=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "LOW")] | length' "$trivy_output" 2>/dev/null || echo "0")
    
    CRITICAL_FINDINGS=$((CRITICAL_FINDINGS + critical))
    HIGH_FINDINGS=$((HIGH_FINDINGS + high))
    MEDIUM_FINDINGS=$((MEDIUM_FINDINGS + medium))
    LOW_FINDINGS=$((LOW_FINDINGS + low))
    
    # Copy to output
    cp "$trivy_output" "$output_file.trivy.json"
    
    # Generate summary
    log_info "Trivy Results: CRITICAL=$critical HIGH=$high MEDIUM=$medium LOW=$low"
    
    rm "$trivy_output"
else
    log_error "Trivy scan failed for $image"
fi
```

}

scan_image_grype() {
local image=$1
local output_file=$2

```
log_info "Scanning $image with Grype..."
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

# Scan with Grype
local grype_output
grype_output=$(mktemp)

grype "$image" \
    --output json \
    --file "$grype_output" \
    2>&1 || true

# Parse results
if [[ -f "$grype_output" ]]; then
    local critical=$(jq '[.matches[]? | select(.vulnerability.severity == "Critical")] | length' "$grype_output" 2>/dev/null || echo "0")
    local high=$(jq '[.matches[]? | select(.vulnerability.severity == "High")] | length' "$grype_output" 2>/dev/null || echo "0")
    local medium=$(jq '[.matches[]? | select(.vulnerability.severity == "Medium")] | length' "$grype_output" 2>/dev/null || echo "0")
    local low=$(jq '[.matches[]? | select(.vulnerability.severity == "Low")] | length' "$grype_output" 2>/dev/null || echo "0")
    
    CRITICAL_FINDINGS=$((CRITICAL_FINDINGS + critical))
    HIGH_FINDINGS=$((HIGH_FINDINGS + high))
    MEDIUM_FINDINGS=$((MEDIUM_FINDINGS + medium))
    LOW_FINDINGS=$((LOW_FINDINGS + low))
    
    # Copy to output
    cp "$grype_output" "$output_file.grype.json"
    
    # Generate summary
    log_info "Grype Results: CRITICAL=$critical HIGH=$high MEDIUM=$medium LOW=$low"
    
    rm "$grype_output"
else
    log_error "Grype scan failed for $image"
fi
```

}

scan_container_images() {
log_section ‚ÄúScanning Container Images‚Äù

```
local images=()

if [[ -n "$IMAGE_NAME" ]]; then
    # Scan specific image
    if [[ -n "$REGISTRY" ]]; then
        images=("$REGISTRY/$IMAGE_NAME")
    else
        images=("$IMAGE_NAME")
    fi
else
    # Scan all images in registry or cluster
    if [[ -n "$REGISTRY" ]]; then
        log_info "Discovering images in registry: $REGISTRY"
        # Azure Container Registry
        if [[ "$REGISTRY" == *".azurecr.io" ]]; then
            local registry_name=${REGISTRY%%.azurecr.io}
            mapfile -t images < <(az acr repository list --name "$registry_name" --output tsv | head -20)
            for i in "${!images[@]}"; do
                images[$i]="$REGISTRY/${images[$i]}:latest"
            done
        fi
    else
        # Scan images in Kubernetes cluster
        log_info "Discovering images in Kubernetes cluster"
        mapfile -t images < <(kubectl get pods --all-namespaces -o jsonpath='{.items[*].spec.containers[*].image}' | tr ' ' '\n' | sort -u | head -20)
    fi
fi

if [[ ${#images[@]} -eq 0 ]]; then
    log_warning "No images found to scan"
    return
fi

log_info "Found ${#images[@]} images to scan"

for image in "${images[@]}"; do
    log_info "Scanning image: $image"
    
    local image_safe_name
    image_safe_name=$(echo "$image" | tr '/:' '_')
    local output_base="$RESULTS_DIR/image-$image_safe_name-$TIMESTAMP"
    
    # Scan with Trivy
    if check_command trivy; then
        scan_image_trivy "$image" "$output_base"
    fi
    
    # Scan with Grype
    if check_command grype; then
        scan_image_grype "$image" "$output_base"
    fi
done

log_success "Container image scanning completed"
```

}

################################################################################

# Dependency Scanning

################################################################################

scan_npm_dependencies() {
log_info ‚ÄúScanning npm dependencies‚Ä¶‚Äù
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

```
# Find all package.json files
local package_files
mapfile -t package_files < <(find "$PROJECT_ROOT" -name "package.json" -not -path "*/node_modules/*" 2>/dev/null)

if [[ ${#package_files[@]} -eq 0 ]]; then
    log_info "No package.json files found"
    return
fi

for package_file in "${package_files[@]}"; do
    local dir
    dir=$(dirname "$package_file")
    log_info "Scanning: $package_file"
    
    # npm audit
    if check_command npm; then
        local npm_output="$RESULTS_DIR/npm-audit-$(basename "$dir")-$TIMESTAMP.json"
        (cd "$dir" && npm audit --json > "$npm_output" 2>&1) || true
        
        if [[ -f "$npm_output" ]]; then
            local critical=$(jq '.metadata.vulnerabilities.critical // 0' "$npm_output")
            local high=$(jq '.metadata.vulnerabilities.high // 0' "$npm_output")
            local medium=$(jq '.metadata.vulnerabilities.moderate // 0' "$npm_output")
            local low=$(jq '.metadata.vulnerabilities.low // 0' "$npm_output")
            
            CRITICAL_FINDINGS=$((CRITICAL_FINDINGS + critical))
            HIGH_FINDINGS=$((HIGH_FINDINGS + high))
            MEDIUM_FINDINGS=$((MEDIUM_FINDINGS + medium))
            LOW_FINDINGS=$((LOW_FINDINGS + low))
            
            log_info "npm audit: CRITICAL=$critical HIGH=$high MEDIUM=$medium LOW=$low"
        fi
    fi
    
    # Snyk test
    if check_command snyk && [[ -n "${SNYK_TOKEN:-}" ]]; then
        local snyk_output="$RESULTS_DIR/snyk-npm-$(basename "$dir")-$TIMESTAMP.json"
        (cd "$dir" && snyk test --json > "$snyk_output" 2>&1) || true
    fi
done
```

}

scan_python_dependencies() {
log_info ‚ÄúScanning Python dependencies‚Ä¶‚Äù
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

```
# Find all requirements.txt files
local req_files
mapfile -t req_files < <(find "$PROJECT_ROOT" -name "requirements.txt" -o -name "Pipfile" 2>/dev/null)

if [[ ${#req_files[@]} -eq 0 ]]; then
    log_info "No Python dependency files found"
    return
fi

for req_file in "${req_files[@]}"; do
    local dir
    dir=$(dirname "$req_file")
    log_info "Scanning: $req_file"
    
    # pip-audit
    if check_command pip-audit; then
        local pip_output="$RESULTS_DIR/pip-audit-$(basename "$dir")-$TIMESTAMP.json"
        (cd "$dir" && pip-audit --format json > "$pip_output" 2>&1) || true
        
        if [[ -f "$pip_output" ]]; then
            local vulnerabilities=$(jq '[.dependencies[].vulns[]] | length' "$pip_output" 2>/dev/null || echo "0")
            HIGH_FINDINGS=$((HIGH_FINDINGS + vulnerabilities))
            log_info "pip-audit: Found $vulnerabilities vulnerabilities"
        fi
    fi
    
    # Snyk test
    if check_command snyk && [[ -n "${SNYK_TOKEN:-}" ]]; then
        local snyk_output="$RESULTS_DIR/snyk-python-$(basename "$dir")-$TIMESTAMP.json"
        (cd "$dir" && snyk test --file="$req_file" --json > "$snyk_output" 2>&1) || true
    fi
done
```

}

scan_dependencies() {
log_section ‚ÄúScanning Dependencies‚Äù

```
# Scan npm dependencies
scan_npm_dependencies

# Scan Python dependencies
scan_python_dependencies

log_success "Dependency scanning completed"
```

}

################################################################################

# Infrastructure as Code Scanning

################################################################################

scan_terraform() {
log_info ‚ÄúScanning Terraform code‚Ä¶‚Äù
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

```
# Find Terraform files
local tf_dirs
mapfile -t tf_dirs < <(find "$PROJECT_ROOT" -name "*.tf" -exec dirname {} \; | sort -u)

if [[ ${#tf_dirs[@]} -eq 0 ]]; then
    log_info "No Terraform files found"
    return
fi

for tf_dir in "${tf_dirs[@]}"; do
    log_info "Scanning Terraform in: $tf_dir"
    
    # tfsec
    if check_command tfsec; then
        local tfsec_output="$RESULTS_DIR/tfsec-$(basename "$tf_dir")-$TIMESTAMP.json"
        tfsec "$tf_dir" --format json --out "$tfsec_output" 2>&1 || true
        
        if [[ -f "$tfsec_output" ]]; then
            local critical=$(jq '[.results[]? | select(.severity == "CRITICAL")] | length' "$tfsec_output" 2>/dev/null || echo "0")
            local high=$(jq '[.results[]? | select(.severity == "HIGH")] | length' "$tfsec_output" 2>/dev/null || echo "0")
            local medium=$(jq '[.results[]? | select(.severity == "MEDIUM")] | length' "$tfsec_output" 2>/dev/null || echo "0")
            local low=$(jq '[.results[]? | select(.severity == "LOW")] | length' "$tfsec_output" 2>/dev/null || echo "0")
            
            CRITICAL_FINDINGS=$((CRITICAL_FINDINGS + critical))
            HIGH_FINDINGS=$((HIGH_FINDINGS + high))
            MEDIUM_FINDINGS=$((MEDIUM_FINDINGS + medium))
            LOW_FINDINGS=$((LOW_FINDINGS + low))
            
            log_info "tfsec: CRITICAL=$critical HIGH=$high MEDIUM=$medium LOW=$low"
        fi
    fi
done
```

}

scan_kubernetes_manifests() {
log_info ‚ÄúScanning Kubernetes manifests‚Ä¶‚Äù
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

```
# Find Kubernetes YAML files
local k8s_files
mapfile -t k8s_files < <(find "$PROJECT_ROOT" -name "*.yaml" -o -name "*.yml" | grep -E "(k8s|kubernetes|deployment|service)" | head -50)

if [[ ${#k8s_files[@]} -eq 0 ]]; then
    log_info "No Kubernetes manifest files found"
    return
fi

# Checkov scan
if check_command checkov; then
    log_info "Running Checkov on Kubernetes manifests..."
    local checkov_output="$RESULTS_DIR/checkov-k8s-$TIMESTAMP.json"
    
    checkov -d "$PROJECT_ROOT" \
        --framework kubernetes \
        --output json \
        --output-file "$checkov_output" \
        2>&1 || true
    
    if [[ -f "$checkov_output" ]]; then
        local failed=$(jq '[.results.failed_checks[]] | length' "$checkov_output" 2>/dev/null || echo "0")
        HIGH_FINDINGS=$((HIGH_FINDINGS + failed))
        log_info "Checkov: Found $failed policy violations"
    fi
fi
```

}

scan_iac() {
log_section ‚ÄúScanning Infrastructure as Code‚Äù

```
# Scan Terraform
scan_terraform

# Scan Kubernetes manifests
scan_kubernetes_manifests

log_success "IaC scanning completed"
```

}

################################################################################

# Kubernetes Cluster Scanning

################################################################################

scan_kubernetes_cluster() {
log_section ‚ÄúScanning Kubernetes Cluster‚Äù
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

```
if ! check_command kubectl; then
    log_warning "kubectl not found, skipping cluster scan"
    return
fi

# Check kubectl connectivity
if ! kubectl cluster-info &> /dev/null; then
    log_error "Cannot connect to Kubernetes cluster"
    return
fi

log_info "Scanning Kubernetes cluster..."

# Get cluster info
local cluster_name
cluster_name=$(kubectl config current-context)
log_info "Cluster: $cluster_name"

# Trivy Kubernetes scan
if check_command trivy; then
    local trivy_k8s_output="$RESULTS_DIR/trivy-k8s-$cluster_name-$TIMESTAMP.json"
    
    log_info "Running Trivy Kubernetes scan..."
    trivy k8s \
        --report summary \
        --format json \
        --output "$trivy_k8s_output" \
        cluster 2>&1 || true
    
    if [[ -f "$trivy_k8s_output" ]]; then
        log_success "Trivy Kubernetes scan completed"
    fi
fi

# Scan running images
log_info "Scanning images running in cluster..."
local running_images
mapfile -t running_images < <(kubectl get pods --all-namespaces -o jsonpath='{.items[*].spec.containers[*].image}' | tr ' ' '\n' | sort -u | head -10)

for image in "${running_images[@]}"; do
    log_info "Quick scan: $image"
    
    if check_command trivy; then
        trivy image --severity HIGH,CRITICAL --quiet "$image" 2>&1 | head -20 || true
    fi
done

log_success "Kubernetes cluster scanning completed"
```

}

################################################################################

# Secret Detection

################################################################################

scan_secrets_detect_secrets() {
log_info ‚ÄúScanning for secrets with detect-secrets‚Ä¶‚Äù
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

```
local output_file="$RESULTS_DIR/detect-secrets-$TIMESTAMP.json"

# Run detect-secrets
detect-secrets scan "$PROJECT_ROOT" \
    --baseline "$output_file" \
    2>&1 || true

if [[ -f "$output_file" ]]; then
    local secrets_count=$(jq '.results | to_entries | length' "$output_file" 2>/dev/null || echo "0")
    CRITICAL_FINDINGS=$((CRITICAL_FINDINGS + secrets_count))
    log_info "detect-secrets: Found $secrets_count potential secrets"
fi
```

}

scan_secrets_gitleaks() {
log_info ‚ÄúScanning for secrets with gitleaks‚Ä¶‚Äù
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

```
local output_file="$RESULTS_DIR/gitleaks-$TIMESTAMP.json"

# Run gitleaks
gitleaks detect \
    --source "$PROJECT_ROOT" \
    --report-format json \
    --report-path "$output_file" \
    --no-git \
    2>&1 || true

if [[ -f "$output_file" ]]; then
    local leaks_count=$(jq 'length' "$output_file" 2>/dev/null || echo "0")
    CRITICAL_FINDINGS=$((CRITICAL_FINDINGS + leaks_count))
    log_info "gitleaks: Found $leaks_count potential leaks"
fi
```

}

scan_secrets() {
log_section ‚ÄúScanning for Secrets‚Äù

```
# detect-secrets
if check_command detect-secrets; then
    scan_secrets_detect_secrets
fi

# gitleaks
if check_command gitleaks; then
    scan_secrets_gitleaks
fi

log_success "Secret scanning completed"
```

}

################################################################################

# SBOM Generation

################################################################################

generate_sbom() {
log_section ‚ÄúGenerating Software Bill of Materials (SBOM)‚Äù

```
if ! check_command syft; then
    log_warning "syft not found, skipping SBOM generation"
    return
fi

if [[ -n "$IMAGE_NAME" ]]; then
    local image="$IMAGE_NAME"
    if [[ -n "$REGISTRY" ]]; then
        image="$REGISTRY/$IMAGE_NAME"
    fi
    
    log_info "Generating SBOM for: $image"
    
    local sbom_file="$RESULTS_DIR/sbom-$(echo "$image" | tr '/:' '_')-$TIMESTAMP.json"
    
    syft "$image" -o spdx-json > "$sbom_file" 2>&1 || true
    
    if [[ -f "$sbom_file" ]]; then
        local packages=$(jq '.packages | length' "$sbom_file" 2>/dev/null || echo "0")
        log_success "SBOM generated: $packages packages found"
    fi
else
    log_info "Generating SBOM for project directory..."
    
    local sbom_file="$RESULTS_DIR/sbom-project-$TIMESTAMP.json"
    
    syft dir:"$PROJECT_ROOT" -o spdx-json > "$sbom_file" 2>&1 || true
    
    if [[ -f "$sbom_file" ]]; then
        log_success "SBOM generated"
    fi
fi
```

}

################################################################################

# Report Generation

################################################################################

generate_summary_report() {
log_section ‚ÄúGenerating Summary Report‚Äù

```
TOTAL_FINDINGS=$((CRITICAL_FINDINGS + HIGH_FINDINGS + MEDIUM_FINDINGS + LOW_FINDINGS))

local report_file="$REPORT_FILE.txt"

cat > "$report_file" << EOF
```

# ================================================================================
VULNERABILITY SCAN REPORT
Crusoe Internal Developer Platform

Generated: $(date ‚Äò+%Y-%m-%d %H:%M:%S‚Äô)
Scan ID: $TIMESTAMP

## SUMMARY

Total Checks: $TOTAL_CHECKS
Total Findings: $TOTAL_FINDINGS

## SEVERITY BREAKDOWN

CRITICAL: $CRITICAL_FINDINGS
HIGH:     $HIGH_FINDINGS
MEDIUM:   $MEDIUM_FINDINGS
LOW:      $LOW_FINDINGS

## SCAN COVERAGE

Container Images: $([ ‚Äú$SCAN_IMAGES‚Äù == ‚Äútrue‚Äù ] && echo ‚Äú‚úì‚Äù || echo ‚Äú‚úó‚Äù)
Dependencies:     $([ ‚Äú$SCAN_DEPENDENCIES‚Äù == ‚Äútrue‚Äù ] && echo ‚Äú‚úì‚Äù || echo ‚Äú‚úó‚Äù)
Infrastructure:   $([ ‚Äú$SCAN_IAC‚Äù == ‚Äútrue‚Äù ] && echo ‚Äú‚úì‚Äù || echo ‚Äú‚úó‚Äù)
Kubernetes:       $([ ‚Äú$SCAN_CLUSTER‚Äù == ‚Äútrue‚Äù ] && echo ‚Äú‚úì‚Äù || echo ‚Äú‚úó‚Äù)
Secrets:          $([ ‚Äú$SCAN_SECRETS‚Äù == ‚Äútrue‚Äù ] && echo ‚Äú‚úì‚Äù || echo ‚Äú‚úó‚Äù)
SBOM:             $([ ‚Äú$SCAN_SBOM‚Äù == ‚Äútrue‚Äù ] && echo ‚Äú‚úì‚Äù || echo ‚Äú‚úó‚Äù)

## DETAILED REPORTS

Individual scan results are available in: $RESULTS_DIR

FILES
$(ls -1 ‚Äú$RESULTS_DIR‚Äù/*$TIMESTAMP* 2>/dev/null | sed ‚Äòs/^/  - /‚Äô)

## RECOMMENDATIONS

EOF

```
if [[ $CRITICAL_FINDINGS -gt 0 ]]; then
    cat >> "$report_file" << EOF
```

‚ö†Ô∏è  CRITICAL: $CRITICAL_FINDINGS critical vulnerabilities found
Action: Immediate remediation required
Priority: Block deployment until resolved
EOF
fi

```
if [[ $HIGH_FINDINGS -gt 0 ]]; then
    cat >> "$report_file" << EOF
```

‚ö†Ô∏è  HIGH: $HIGH_FINDINGS high severity vulnerabilities found
Action: Plan remediation within 7 days
Priority: Monitor and track resolution
EOF
fi

```
if [[ $MEDIUM_FINDINGS -gt 0 ]]; then
    cat >> "$report_file" << EOF
```

‚ÑπÔ∏è  MEDIUM: $MEDIUM_FINDINGS medium severity vulnerabilities found
Action: Plan remediation within 30 days
Priority: Include in next sprint
EOF
fi

```
if [[ $TOTAL_FINDINGS -eq 0 ]]; then
    cat >> "$report_file" << EOF
```

‚úÖ No vulnerabilities found above $SEVERITY_THRESHOLD threshold
Status: All security checks passed
EOF
fi

```
cat >> "$report_file" << EOF
```

================================================================================
EOF

```
log_success "Summary report generated: $report_file"

# Display report
cat "$report_file"

# Generate JSON report
generate_json_report

# Generate HTML report if requested
if [[ "$OUTPUT_FORMAT" == "html" ]]; then
    generate_html_report
fi
```

}

generate_json_report() {
local json_file=‚Äù$REPORT_FILE.json‚Äù

```
cat > "$json_file" << EOF
```

{
‚Äúscan_id‚Äù: ‚Äú$TIMESTAMP‚Äù,
‚Äútimestamp‚Äù: ‚Äú$(date -u +%Y-%m-%dT%H:%M:%SZ)‚Äù,
‚Äúplatform‚Äù: ‚ÄúCrusoe IDP‚Äù,
‚Äústatistics‚Äù: {
‚Äútotal_checks‚Äù: $TOTAL_CHECKS,
‚Äútotal_findings‚Äù: $TOTAL_FINDINGS,
‚Äúcritical‚Äù: $CRITICAL_FINDINGS,
‚Äúhigh‚Äù: $HIGH_FINDINGS,
‚Äúmedium‚Äù: $MEDIUM_FINDINGS,
‚Äúlow‚Äù: $LOW_FINDINGS
},
‚Äúscan_coverage‚Äù: {
‚Äúimages‚Äù: $SCAN_IMAGES,
‚Äúdependencies‚Äù: $SCAN_DEPENDENCIES,
‚Äúinfrastructure‚Äù: $SCAN_IAC,
‚Äúkubernetes‚Äù: $SCAN_CLUSTER,
‚Äúsecrets‚Äù: $SCAN_SECRETS,
‚Äúsbom‚Äù: $SCAN_SBOM
},
‚Äúseverity_threshold‚Äù: ‚Äú$SEVERITY_THRESHOLD‚Äù,
‚Äúresults_directory‚Äù: ‚Äú$RESULTS_DIR‚Äù
}
EOF

```
log_success "JSON report generated: $json_file"
```

}

generate_html_report() {
local html_file=‚Äù$REPORT_FILE.html‚Äù

```
cat > "$html_file" << 'EOF'
```

<!DOCTYPE html>

<html>
<head>
    <title>Vulnerability Scan Report - Crusoe IDP</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .header { background: #2c3e50; color: white; padding: 20px; margin: -20px -20px 20px -20px; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat-box { border: 1px solid #ddd; padding: 15px; text-align: center; border-radius: 4px; }
        .stat-value { font-size: 2em; font-weight: bold; }
        .critical { color: #c0392b; }
        .high { color: #e67e22; }
        .medium { color: #f39c12; }
        .low { color: #3498db; }
        .success { color: #27ae60; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background: #34495e; color: white; }
        .badge { padding: 4px 8px; border-radius: 3px; font-size: 0.85em; }
        .badge-success { background: #27ae60; color: white; }
        .badge-warning { background: #f39c12; color: white; }
    </style>
</head>
<body>
EOF

```
cat >> "$html_file" << EOF
<div class="container">
    <div class="header">
        <h1>Vulnerability Scan Report</h1>
        <p>Crusoe Internal Developer Platform</p>
        <p>Generated: $(date '+%Y-%m-%d %H:%M:%S')</p>
    </div>
    
    <div class="stats">
        <div class="stat-box">
            <div class="stat-value">$TOTAL_CHECKS</div>
            <div>Total Checks</div>
        </div>
        <div class="stat-box">
            <div class="stat-value critical">$CRITICAL_FINDINGS</div>
            <div>Critical</div>
        </div>
        <div class="stat-box">
            <div class="stat-value high">$HIGH_FINDINGS</div>
            <div>High</div>
        </div>
        <div class="stat-box">
            <div class="stat-value medium">$MEDIUM_FINDINGS</div>
            <div>Medium</div>
        </div>
        <div class="stat-box">
            <div class="stat-value low">$LOW_FINDINGS</div>
            <div>Low</div>
        </div>
    </div>
    
    <h2>Scan Coverage</h2>
    <table>
        <tr>
            <th>Category</th>
            <th>Status</th>
        </tr>
        <tr>
            <td>Container Images</td>
            <td>$([ "$SCAN_IMAGES" == "true" ] && echo '<span class="badge badge-success">‚úì Scanned</span>' || echo '<span class="badge badge-warning">‚úó Skipped</span>')</td>
        </tr>
        <tr>
            <td>Dependencies</td>
            <td>$([ "$SCAN_DEPENDENCIES" == "true" ] && echo '<span class="badge badge-success">‚úì Scanned</span>' || echo '<span class="badge badge-warning">‚úó Skipped</span>')</td>
        </tr>
        <tr>
            <td>Infrastructure as Code</td>
            <td>$([ "$SCAN_IAC" == "true" ] && echo '<span class="badge badge-success">‚úì Scanned</span>' || echo '<span class="badge badge-warning">‚úó Skipped</span>')</td>
        </tr>
        <tr>
            <td>Kubernetes Cluster</td>
            <td>$([ "$SCAN_CLUSTER" == "true" ] && echo '<span class="badge badge-success">‚úì Scanned</span>' || echo '<span class="badge badge-warning">‚úó Skipped</span>')</td>
        </tr>
        <tr>
            <td>Secrets Detection</td>
            <td>$([ "$SCAN_SECRETS" == "true" ] && echo '<span class="badge badge-success">‚úì Scanned</span>' || echo '<span class="badge badge-warning">‚úó Skipped</span>')</td>
        </tr>
    </table>
</div>
```

</body>
</html>
EOF

```
log_success "HTML report generated: $html_file"
```

}

################################################################################

# Notifications

################################################################################

send_notifications() {
if [[ ‚Äú$SEND_NOTIFICATIONS‚Äù != ‚Äútrue‚Äù ]]; then
return
fi

```
log_info "Sending notifications..."

# Slack notification
if [[ -n "${SLACK_WEBHOOK_URL:-}" ]]; then
    local severity_emoji="‚úÖ"
    local color="good"
    
    if [[ $CRITICAL_FINDINGS -gt 0 ]]; then
        severity_emoji="üö®"
        color="danger"
    elif [[ $HIGH_FINDINGS -gt 0 ]]; then
        severity_emoji="‚ö†Ô∏è"
        color="warning"
    fi
    
    local payload=$(cat << EOF
```

{
‚Äúattachments‚Äù: [
{
‚Äúcolor‚Äù: ‚Äú$color‚Äù,
‚Äútitle‚Äù: ‚Äú$severity_emoji Vulnerability Scan Report‚Äù,
‚Äúfields‚Äù: [
{
‚Äútitle‚Äù: ‚ÄúCritical‚Äù,
‚Äúvalue‚Äù: ‚Äú$CRITICAL_FINDINGS‚Äù,
‚Äúshort‚Äù: true
},
{
‚Äútitle‚Äù: ‚ÄúHigh‚Äù,
‚Äúvalue‚Äù: ‚Äú$HIGH_FINDINGS‚Äù,
‚Äúshort‚Äù: true
},
{
‚Äútitle‚Äù: ‚ÄúMedium‚Äù,
‚Äúvalue‚Äù: ‚Äú$MEDIUM_FINDINGS‚Äù,
‚Äúshort‚Äù: true
},
{
‚Äútitle‚Äù: ‚ÄúLow‚Äù,
‚Äúvalue‚Äù: ‚Äú$LOW_FINDINGS‚Äù,
‚Äúshort‚Äù: true
}
],
‚Äúfooter‚Äù: ‚ÄúCrusoe IDP Security‚Äù,
‚Äúts‚Äù: $(date +%s)
}
]
}
EOF
)

```
    curl -X POST -H 'Content-type: application/json' \
        --data "$payload" \
        "$SLACK_WEBHOOK_URL" 2>&1 > /dev/null || true
    
    log_success "Slack notification sent"
fi
```

}

################################################################################

# Main Execution

################################################################################

usage() {
cat << EOF
Usage: $0 [OPTIONS]

Vulnerability scanner for Crusoe IDP

OPTIONS:
‚Äìall                   Run all scans
‚Äìimages                Scan container images
‚Äìdependencies          Scan dependencies
‚Äìiac                   Scan infrastructure as code
‚Äìcluster              Scan Kubernetes cluster
‚Äìsecrets              Scan for secrets
‚Äìsbom                 Generate SBOM

```
--image IMAGE          Specific image to scan
--registry REGISTRY    Container registry
--severity LEVEL       Severity threshold (CRITICAL|HIGH|MEDIUM|LOW)
--format FORMAT        Output format (text|json|html)
--output FILE          Output file path

--no-update            Skip database updates
--notify               Send notifications
--fail-on-critical     Fail if critical findings (default: true)
--fail-on-high         Fail if high findings

-h, --help             Show this help message
```

EXAMPLES:
# Run all scans
$0 ‚Äìall

```
# Scan specific image
$0 --images --image myapp:v1.0.0 --registry acridpdev.azurecr.io

# Scan dependencies and secrets
$0 --dependencies --secrets

# Generate HTML report
$0 --all --format html --output scan-report.html

# Scan with notifications
$0 --all --notify --fail-on-high
```

EOF
}

parse_arguments() {
while [[ $# -gt 0 ]]; do
case $1 in
‚Äìall)
SCAN_ALL=true
SCAN_IMAGES=true
SCAN_DEPENDENCIES=true
SCAN_IAC=true
SCAN_CLUSTER=true
SCAN_SECRETS=true
SCAN_SBOM=true
shift
;;
‚Äìimages)
SCAN_IMAGES=true
shift
;;
‚Äìdependencies)
SCAN_DEPENDENCIES=true
shift
;;
‚Äìiac)
SCAN_IAC=true
shift
;;
‚Äìcluster)
SCAN_CLUSTER=true
shift
;;
‚Äìsecrets)
SCAN_SECRETS=true
shift
;;
‚Äìsbom)
SCAN_SBOM=true
shift
;;
‚Äìimage)
IMAGE_NAME=‚Äù$2‚Äù
shift 2
;;
‚Äìregistry)
REGISTRY=‚Äù$2‚Äù
shift 2
;;
‚Äìseverity)
SEVERITY_THRESHOLD=‚Äù$2‚Äù
shift 2
;;
‚Äìformat)
OUTPUT_FORMAT=‚Äù$2‚Äù
shift 2
;;
‚Äìoutput)
REPORT_FILE=‚Äù$2‚Äù
shift 2
;;
‚Äìno-update)
UPDATE_DB=false
shift
;;
‚Äìnotify)
SEND_NOTIFICATIONS=true
shift
;;
‚Äìfail-on-critical)
FAIL_ON_CRITICAL=true
shift
;;
‚Äìfail-on-high)
FAIL_ON_HIGH=true
shift
;;
-h|‚Äìhelp)
usage
exit 0
;;
*)
log_error ‚ÄúUnknown option: $1‚Äù
usage
exit 1
;;
esac
done
}

main() {
log_section ‚ÄúVulnerability Scanner - Crusoe IDP‚Äù
log_info ‚ÄúStarting vulnerability scan at $(date)‚Äù

```
# Parse command line arguments
parse_arguments "$@"

# Validate options
if [[ "$SCAN_ALL" == "false" ]] && \
   [[ "$SCAN_IMAGES" == "false" ]] && \
   [[ "$SCAN_DEPENDENCIES" == "false" ]] && \
   [[ "$SCAN_IAC" == "false" ]] && \
   [[ "$SCAN_CLUSTER" == "false" ]] && \
   [[ "$SCAN_SECRETS" == "false" ]] && \
   [[ "$SCAN_SBOM" == "false" ]]; then
    log_error "No scan type specified. Use --all or specify individual scans."
    usage
    exit 1
fi

# Create results directory
mkdir -p "$RESULTS_DIR"

# Check and install required tools
check_and_install_tools

# Update vulnerability databases
update_vulnerability_databases

# Run scans
if [[ "$SCAN_IMAGES" == "true" ]] || [[ "$SCAN_ALL" == "true" ]]; then
    scan_container_images
fi

if [[ "$SCAN_DEPENDENCIES" == "true" ]] || [[ "$SCAN_ALL" == "true" ]]; then
    scan_dependencies
fi

if [[ "$SCAN_IAC" == "true" ]] || [[ "$SCAN_ALL" == "true" ]]; then
    scan_iac
fi

if [[ "$SCAN_CLUSTER" == "true" ]] || [[ "$SCAN_ALL" == "true" ]]; then
    scan_kubernetes_cluster
fi

if [[ "$SCAN_SECRETS" == "true" ]] || [[ "$SCAN_ALL" == "true" ]]; then
    scan_secrets
fi

if [[ "$SCAN_SBOM" == "true" ]] || [[ "$SCAN_ALL" == "true" ]]; then
    generate_sbom
fi

# Generate reports
generate_summary_report

# Send notifications
send_notifications

# Determine exit code
local exit_code=0

if [[ "$FAIL_ON_CRITICAL" == "true" ]] && [[ $CRITICAL_FINDINGS -gt 0 ]]; then
    log_error "Scan failed: $CRITICAL_FINDINGS critical vulnerabilities found"
    exit_code=2
elif [[ "$FAIL_ON_HIGH" == "true" ]] && [[ $HIGH_FINDINGS -gt 0 ]]; then
    log_warning "Scan completed with warnings: $HIGH_FINDINGS high vulnerabilities found"
    exit_code=1
fi

log_section "Scan Complete"
log_info "Results saved to: $RESULTS_DIR"

if [[ $exit_code -eq 0 ]]; then
    log_success "Vulnerability scan completed successfully"
fi

exit $exit_code
```

}

# Run main function

main ‚Äú$@‚Äù
